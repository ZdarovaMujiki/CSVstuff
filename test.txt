Изначально я paccмaтpивaл JavaScript как «еще один язык программирования»; во
многих отношениях так оно и есть.
Но с течением времени и углублением моих знаний я начал видеть, что исходный замысел этого языка отличался от других языков, которые я видел прежде.
Программирование состоит в управлении сложностью: сложность решаемой проблемы
накладывается на сложность машины, на которой она решается. Именно из-за этих
трудностей большинство программных проектов завершается неудачей. И до сих пор
ни один из языков, которые я знаю, не был смоделирован и создан прежде всего для
преодоления сложности разработки и сопровождения программ1. Конечно, многие
решения при создании языков были сделаны в расчете на управление сложностью,
но при этом всегда находились другие аспекты, достаточно важные, чтобы учитывать
это при проектировании языка. Все это неизбежно приводило к тому, что программист
рано или поздно заходил в тупик. Например, язык С++ создавался в расчете на продуктивность и обратную совместимость с С (чтобы упростить переход с этого языка на
С++). Оба решения, несомненно, полезны и стали одними из причин успеха С++, но
также они выявили дополнительные трудности, что не позволило успешно воплотить
в жизнь некоторые проекты (конечно, можно винить программистов и руководителей
проекта, но если язык в силах помочь в устранении ошибок, почему бы этим не воспользоваться?). Как другой пример подойдет Visual Basic (VB), привязанный к языку
BASIC, который изначально не был рассчитан на расширение, из-за чего все расширения языка, созданные для VB, имеют ужасный синтаксис, создающий массу проблем
с сопровождением. Язык Perl был основан на awk, sed, grep и других средствах UNIX,
которые он должен был заменить, и в результате при работе с Perl программист через
какое-то время уже не может разобраться в собственном коде. С другой стороны, С++,
VB, Perl и другие языки, подобные Smalltalk, частично фокусировались на преодолении
трудностей и, как следствие, преуспели в решении определенных типов задач.